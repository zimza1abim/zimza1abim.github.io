---
layout: post
title: 취약점 진단 및 대응 실무 5日 / SeSAC 성동캠퍼스1기
description: >
  [클라우드 기반의 모빌리티 융합보안 과정] 취약점 진단 및 대응 실무 5日차 수업 정리한 내용입니다.
image: /assets/img/blog/cover-4.jpg
comments: true
#sitemap: false
#published : false
categories: [study,security-vulnerability]
tags: [sesac,cloud,skshieldus,security-vulnerability]
related_posts:
#  - _posts/study/python/2023-10-31-day2.md
#  - _posts/study/python/2023-11-01-day3.md
#  - _posts/study/python/2023-11-02-day4.md
---
* toc
{:toc}

<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube.com/embed/xgXeZeQiF1o' frameborder='0' allowfullscreen></iframe></div>

## 취약점 진단 및 대응 실무 / 4주차 5일자 수업

### 1. frida-lab

#### 1-1. Nox Player와 frida-lab

adb로 연결한 Nox Player로 frida-lab을 실행하여 아래의 문제를 푸는 내용입니다.
{:.lead}

```javascript
setImmediate(function(){ 
    Java.perform(function(){
        // 문제는 uk.rossmarks.fridalab 클래스의 challenge_01 메소드를 호출하고
        // 리턴되는 값이 1일 경우 문제가 풀리게 됨
        // uk.rossmarks.fridalab.challenge_01 메소드를 찾아
        // 내부 멤버인 int chall01;
        // 값을 강제로 1로 변경
        var chal01 = Java.use("uk.rossmarks.fridalab.challenge_01");
        // uk.rossmarks.fridalab.challenge_01 메소드를 찾아
        chal01.chall01.value = 1;
        // 내부 멤버인 int chall01;
        // 값을 강제로 1로 변경
        console.log("Solved Challenge 01");

        // uk.rossmarks.fridalab.MainActivity 클래스를 찾고
        Java.choose("uk.rossmarks.fridalab.MainActivity", {
            // uk.rossmarks.fridalab.MainActivity 클래스가 chall_02 변수에 담겨짐
            onMatch : function(chall_02) {
                // chall_02 의 chall02 메소드를 호출
                chall_02.chall02();                
            },
            onComplete : function(){
                console.log("Solved Challenge 02");
            }            
        })    
        console.log("Solved Challenge 03");
        // MainActivity Class 를 찾고
        var activity = Java.use("uk.rossmarks.fridalab.MainActivity");
        // chall03 메소드를 구현
        activity.chall03.implementation = function() {
            // send("[*] chall03 return value switch"); 
            // 강제로 리턴값을 true 로 고정
            return true;
        }

        // uk.rossmarks.fridalab.MainActivity 클래스를 찾고
        Java.choose("uk.rossmarks.fridalab.MainActivity", {
            // uk.rossmarks.fridalab.MainActivity 클래스가 chall_04 에 담겨짐
            onMatch : function(chall_04) {
                // chall_04 클래스의 chall04 메소드를 String str 에 frida
                // 값과 함께 호출
                chall_04.chall04("frida");
                console.log("Solved Challenge 04");
            },
            onComplete : function(){                
            }            
        })        
        console.log("Solved Challenge 05");    
        var activity = Java.use("uk.rossmarks.fridalab.MainActivity");            
        
        activity.chall05.overload("java.lang.String").implementation = function(arg){
            this.chall05("frida");
            
        } 
        Java.choose("uk.rossmarks.fridalab.MainActivity", {
            "onMatch" : function(chall_06){
                chall_06.chall06(42);
            },
            "onComplete" : function(){
                console.log("Solved Challenge 06");
            }
        });

        var chal06 = Java.use("uk.rossmarks.fridalab.challenge_06");

        chal06.confirmChall06.overload("int").implementation = function(arg){
            return true;
        };

        Java.choose("uk.rossmarks.fridalab.MainActivity", {
            "onMatch" : function(chall_06){
                chall_06.chall06(42);
            },
            "onComplete" : function(){
                console.log("Solved Challenge 06");
            }
        });

        Java.choose("uk.rossmarks.fridalab.MainActivity", {
            onMatch : function(ch6) {
                ch6.chall06(Java.use("uk.rossmarks.fridalab.challenge_06").chall06.value);
            }, onComplete: function() {}
        });

                var chal06 = Java.use("uk.rossmarks.fridalab.challenge_06");

        chal06.confirmChall06.overload("int").implementation = function(arg){
            return true;
        };

        Java.choose("uk.rossmarks.fridalab.MainActivity", {
            "onMatch" : function(chall_06){
                chall_06.chall06(42);
            },
            "onComplete" : function(){
                console.log("Solved Challenge 06");
            }
        });

        for (var i = 0; i < 10000; ++i) {
            if (Java.use('uk.rossmarks.fridalab.challenge_07').check07Pin(String(i))) {
                Java.choose("uk.rossmarks.fridalab.MainActivity", {
                    onMatch : function(ch7) {
                        ch7.chall07(String(i));
                    }, onComplete: function() {}
                });
                break;
            }
        }

    });
});
```

![day4-3.png](/assets/img/docs/appsec/day4/3.png){:.lead width="800" height="100" loading="lazy"}
adb로 frida-lab 실행.
{:.figcaption}

*이렇게 2주간의 애플리케이션 및 취약점 진단에 대한 2과목을 배워봤습니다. 사실 너무 빨리 지나가서 아쉬운 마음이 큽니다. 솔직히 올리디버거나 어셈블리 할 땐, 음오아예x18... 하지만 시간이 지나면서 약간 뭔가 재밌어지고 그동안 배웠던 과목중에는 제일 흥미롭게 다가왔던 것 같습니다. 가르쳐주시는 강사님도 굵직한 경험이 많으셔서 그런지 몰라도 얘기하는거에 신뢰성이 있었습니다. 아직 많이 이해가 필요하고 뭔가 부족한 것 같지만 그래도 지금까지는 제일 재밌었던 수업인 것 같았습니다.*
{:.faded}